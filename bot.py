# -*- coding: utf-8 -*-
"""bot.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1znmQ_m7bOyMvLHUcAbvZkuvUWx0YQ6Cc
"""

import os
import discord
from discord import app_commands
from discord.ext import commands
import random
import json
import datetime
import pytz
from datetime import datetime, timezone
import asyncio

# ============ CONFIGURATION ============
TOKEN = os.environ.get('DISCORD_TOKEN')

if not TOKEN:
    raise ValueError("âŒ DISCORD_TOKEN manquant ! Configure-le dans les variables d'environnement Railway.")

# Chemins adaptÃ©s pour Railway
SAVE_PATH = os.path.join(os.getcwd(), "bot_data")
os.makedirs(SAVE_PATH, exist_ok=True)
STATE_FILE = os.path.join(SAVE_PATH, "calendrier_state.json")
COIN_FILE = os.path.join(SAVE_PATH, "coins.json")

# RÃ©compenses calendrier
rewards = [
    ("ğŸ Bon rÃ´le", 30),
    ("â„ï¸ TrÃ¨s bon rÃ´le", 10),
    ("ğŸ‘ Brainrot 10M+", 5),
    ("ğŸ… Staff", 3),
    ("ğŸŒŸ Brainrot 25M+ / Grande combi", 1),
    ("ğŸ‘‘ Surprise...", 0.5)
]

# ============ UTILITAIRES ============
def weighted_random_choice(reward_list):
    names = [r[0] for r in reward_list]
    weights = [r[1] for r in reward_list]
    return random.choices(names, weights=weights, k=1)[0]

def load_state():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {"users": {}}

def save_state(state):
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f, ensure_ascii=False, indent=2)

def load_coins():
    if os.path.exists(COIN_FILE):
        with open(COIN_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {"coins": {}, "daily": {}}

def save_coins(data):
    with open(COIN_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

# ============ BOT ============
intents = discord.Intents.default()
bot = commands.Bot(command_prefix="!", intents=intents)
tree = bot.tree

@bot.event
async def on_ready():
    try:
        await tree.sync()
        print(f"âœ… ConnectÃ© en tant que {bot.user} (id: {bot.user.id})")
        print(f"âœ… Commandes synchronisÃ©es")
    except Exception as e:
        print(f"âŒ Erreur lors du sync des commandes : {e}")

# ============ CALENDRIER DE L'AVENT ============
@tree.command(name="calendrier", description="Ouvre la case du jour du calendrier de l'avent ğŸ„")
async def calendrier(interaction: discord.Interaction):
    await interaction.response.defer()
    user_id = str(interaction.user.id)
    today = datetime.now(timezone.utc).date().isoformat()

    state = load_state()
    last_date = state.get("users", {}).get(user_id)

    if last_date == today:
        await interaction.followup.send(
            f"âŒ Tu as dÃ©jÃ  ouvert ta case aujourd'hui, {interaction.user.mention} ! Reviens demain ğŸ"
        )
        return

    reward = weighted_random_choice(rewards)
    state.setdefault("users", {})[user_id] = today
    save_state(state)

    embed = discord.Embed(title="ğŸ‰ Calendrier de l'Avent", color=0x8B0000)
    embed.add_field(name="FÃ©licitations !", value=f"{interaction.user.mention}, tu as gagnÃ© **{reward}**", inline=False)
    embed.set_footer(text="Une utilisation possible par jour. Bonnes fÃªtes !")

    await interaction.followup.send(embed=embed)

@tree.command(name="liste_recompenses", description="(Admin) Affiche les rÃ©compenses et leurs poids")
async def liste_recompenses(interaction: discord.Interaction):
    s = "\n".join([f"{r[0]} â€” poids {r[1]}" for r in rewards])
    await interaction.response.send_message(f"RÃ©compenses actuelles :\n{s}")

@tree.command(name="set_chance", description="(Admin) Change la probabilitÃ© d'une rÃ©compense")
@app_commands.describe(nom="Nom de la rÃ©compense", nouvelle_chance="Nouvelle chance en % (ex: 0.5 pour 0.5%)")
async def set_chance(interaction: discord.Interaction, nom: str, nouvelle_chance: float):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("âŒ Tu n'as pas la permission d'utiliser cette commande.", ephemeral=True)
        return

    for i, (reward_name, _) in enumerate(rewards):
        if reward_name.lower() == nom.lower():
            rewards[i] = (reward_name, nouvelle_chance)
            await interaction.response.send_message(f"âœ… La chance de **{reward_name}** est maintenant {nouvelle_chance} %")
            return

    await interaction.response.send_message(f"âŒ RÃ©compense **{nom}** introuvable.", ephemeral=True)

# ============ MODÃ‰RATION ============
@tree.command(name="ban", description="Bannir un utilisateur du serveur (admin uniquement)")
@app_commands.describe(user="Utilisateur Ã  bannir", reason="Raison du bannissement")
async def ban(interaction: discord.Interaction, user: discord.Member, reason: str = "Aucune raison fournie"):
    if not interaction.user.guild_permissions.ban_members:
        await interaction.response.send_message("âŒ Tu n'as pas la permission de bannir des membres.", ephemeral=True)
        return

    if not interaction.guild.me.guild_permissions.ban_members:
        await interaction.response.send_message("âŒ Je n'ai pas la permission de bannir des membres.", ephemeral=True)
        return

    if user == interaction.user:
        await interaction.response.send_message("âŒ Tu ne peux pas te bannir toi-mÃªme.", ephemeral=True)
        return
    if user == interaction.guild.owner:
        await interaction.response.send_message("âŒ Impossible de bannir le propriÃ©taire du serveur.", ephemeral=True)
        return

    try:
        await user.ban(reason=reason)
        await interaction.response.send_message(f"âœ… {user.mention} a Ã©tÃ© banni.\nRaison : {reason}")
    except Exception as e:
        await interaction.response.send_message(f"âŒ Impossible de bannir l'utilisateur : {e}", ephemeral=True)

# ============ GIVEAWAY ============
@bot.tree.command(name="giveawaystart", description="CrÃ©er un giveaway")
@app_commands.describe(temps="DurÃ©e (ex: 1h, 30m, 2d)", prix="RÃ©compense")
async def gstart(interaction: discord.Interaction, temps: str, prix: str):
    temps = temps.lower()
    if temps.endswith("s"):
        total_seconds = int(temps[:-1])
    elif temps.endswith("m"):
        total_seconds = int(temps[:-1]) * 60
    elif temps.endswith("h"):
        total_seconds = int(temps[:-1]) * 3600
    elif temps.endswith("d"):
        total_seconds = int(temps[:-1]) * 86400
    else:
        await interaction.response.send_message(
            "âŒ Format invalide ! Exemple : `30s`, `10m`, `2h`, `1d`",
            ephemeral=True
        )
        return

    paris = pytz.timezone("Europe/Paris")
    now = datetime.now(paris)
    end_time = now + datetime.timedelta(seconds=total_seconds)
    timestamp = int(end_time.timestamp())

    embed = discord.Embed(
        title="ğŸ‰ Giveaway !",
        description=(
            f"**RÃ©compense :** {prix}\n"
            f"**Fin :** <t:{timestamp}:F> (<t:{timestamp}:R>)\n"
            f"RÃ©agissez avec ğŸ‰ pour participer !"
        ),
        color=0x00ff00
    )

    msg = await interaction.channel.send(embed=embed)
    await msg.add_reaction("ğŸ‰")

    await interaction.response.send_message(
        f"Giveaway lancÃ© ! Fin prÃ©vue <t:{timestamp}:R>.",
        ephemeral=True
    )

    async def end_giveaway():
        await asyncio.sleep(total_seconds)

        msg_final = await interaction.channel.fetch_message(msg.id)
        participants = []
        for reaction in msg_final.reactions:
            if str(reaction.emoji) == "ğŸ‰":
                async for user in reaction.users():
                    if not user.bot:
                        participants.append(user)

        if participants:
            winner = random.choice(participants)
            embed_end = discord.Embed(
                title="ğŸ† Giveaway terminÃ© !",
                description=f"ğŸ‰ **Gagnant : {winner.mention}**\nRÃ©compense : {prix}",
                color=0xFFD700
            )
        else:
            embed_end = discord.Embed(
                title="ğŸ Giveaway terminÃ©",
                description="ğŸ˜¢ Personne n'a participÃ©.",
                color=0xFF0000
            )

        await interaction.channel.send(embed=embed_end)

    asyncio.create_task(end_giveaway())

@bot.tree.command(name="giveawayreroll", description="Reroll un giveaway existant (admin uniquement)")
@app_commands.describe(message_id="ID du message du giveaway")
async def giveaway_reroll(interaction: discord.Interaction, message_id: str):
    if not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message(
            "âŒ Tu n'as pas la permission d'utiliser ce reroll.",
            ephemeral=True
        )
        return

    try:
        msg = await interaction.channel.fetch_message(int(message_id))
    except:
        await interaction.response.send_message(
            "âŒ Impossible de trouver le message. VÃ©rifie l'ID du message.",
            ephemeral=True
        )
        return

    participants = []
    for reaction in msg.reactions:
        if str(reaction.emoji) == "ğŸ‰":
            async for user in reaction.users():
                if not user.bot:
                    participants.append(user)

    if not participants:
        await interaction.response.send_message(
            "ğŸ˜¢ Personne n'a participÃ©, impossible de faire un reroll.",
            ephemeral=True
        )
        return

    new_winner = random.choice(participants)

    embed = discord.Embed(
        title="ğŸ”„ Nouveau gagnant (Reroll) !",
        description=f"ğŸ‰ **Nouveau gagnant : {new_winner.mention}**",
        color=0x00FFEA
    )

    await interaction.channel.send(embed=embed)
    await interaction.response.send_message("ğŸ”„ Reroll effectuÃ© avec succÃ¨s !", ephemeral=True)

# ============ SYSTÃˆME DE COINS ============
@bot.tree.command(name="coins", description="Affiche ton nombre de coins ğŸ’°")
async def coins(interaction: discord.Interaction):
    data = load_coins()
    user_id = str(interaction.user.id)
    balance = data["coins"].get(user_id, 0)

    embed = discord.Embed(
        title="ğŸ’° Ton solde",
        description=f"{interaction.user.mention}, tu as **{balance} coins**.",
        color=0xFFD700
    )
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="daily", description="RÃ©cupÃ¨re ta rÃ©compense journaliÃ¨re ğŸ’¸")
async def daily(interaction: discord.Interaction):
    data = load_coins()
    user_id = str(interaction.user.id)

    today = datetime.now(timezone.utc).date().isoformat()
    last_claim = data["daily"].get(user_id)

    if last_claim == today:
        await interaction.response.send_message(
            f"âŒ Tu as dÃ©jÃ  pris ton **daily** aujourd'hui, {interaction.user.mention} !",
            ephemeral=True
        )
        return

    amount = random.randint(50, 150)

    data["coins"][user_id] = data["coins"].get(user_id, 0) + amount
    data["daily"][user_id] = today
    save_coins(data)

    embed = discord.Embed(
        title="ğŸ RÃ©compense journaliÃ¨re",
        description=f"Tu gagnes **{amount} coins** !",
        color=0x00FF00
    )
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="pay", description="Donne des coins Ã  un utilisateur ğŸ’µ")
@app_commands.describe(member="Ã€ qui donner ?", amount="Montant Ã  donner")
async def pay(interaction: discord.Interaction, member: discord.Member, amount: int):
    if amount <= 0:
        await interaction.response.send_message("âŒ Montant invalide.", ephemeral=True)
        return

    data = load_coins()
    sender = str(interaction.user.id)
    receiver = str(member.id)

    sender_balance = data["coins"].get(sender, 0)

    if sender_balance < amount:
        await interaction.response.send_message("âŒ Tu n'as pas assez de coins.", ephemeral=True)
        return

    data["coins"][sender] -= amount
    data["coins"][receiver] = data["coins"].get(receiver, 0) + amount
    save_coins(data)

    embed = discord.Embed(
        title="ğŸ’¸ Transfert effectuÃ©",
        description=(
            f"{interaction.user.mention} a donnÃ© **{amount} coins** Ã  {member.mention} !"
        ),
        color=0x00A3FF
    )
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="leaderboard", description="Affiche le classement des joueurs les plus riches ğŸ’")
async def leaderboard(interaction: discord.Interaction):
    data = load_coins()
    coins_data = data.get("coins", {})

    if not coins_data:
        await interaction.response.send_message("ğŸ’¤ Personne n'a encore de coins.", ephemeral=True)
        return

    sorted_users = sorted(coins_data.items(), key=lambda x: x[1], reverse=True)

    embed = discord.Embed(
        title="ğŸ† Leaderboard",
        color=0xFFD700
    )

    desc = ""
    rank = 1
    top = sorted_users[:10]

    for user_id, amount in top:
        member = interaction.guild.get_member(int(user_id))

        if member is None:
            display_name = f"Utilisateur inconnu ({user_id})"
        else:
            display_name = member.mention

        desc += f"**#{rank}** â€” {display_name} : **{amount} coins**\n"
        rank += 1

    embed.description = desc
    embed.set_footer(text="Classement basÃ© sur les coins enregistrÃ©s.")

    await interaction.response.send_message(embed=embed)

# ============ LANCEMENT ============
if __name__ == "__main__":
    print("ğŸš€ DÃ©marrage du bot...")
    bot.run(TOKEN)